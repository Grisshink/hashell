use std::collections::vec_deque::VecDeque;

static ALPHABET: &str = " 0123456789_-~+*/|\\^%&@#№<>()[]{}.,:;!?\"'`abcdefghijklmnopqrstvuwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
static MAX_CODE: u32 = 1000;
static ALF_PRIME: u32 = 103;
static BIG_PRIME: u32 = 12345701;
static PRIMELIST: [u32; 102] = [
    5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,
    103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,
    313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431,
    433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,
    563, 569,
];

static EXP_VARS: [f64; 130] = [
    37.0,
    1369.0,
    50653.0,
    1874161.0,
    69343957.0,
    2565726409.0,
    94931877133.0,
    3512479453921.0,
    129961739795077.0,
    4808584372417840.0,
    177917621779460300.0,
    6582952005840040000.0,
    243569224216081760000.0,
    41.0,
    1681.0,
    68921.0,
    2825761.0,
    115856201.0,
    4750104241.0,
    194754273881.0,
    7984925229121.0,
    327381934393962.0,
    13422659310152444.0,
    550329031716250800.0,
    22563490300366143000.0,
    925103102315013000000.0,
    43.0,
    1849.0,
    79507.0,
    3418801.0,
    147008443.0,
    6321363049.0,
    271818611107.0,
    11688200277601.0,
    502592611936844.0,
    21611482313284296.0,
    929293739471224300.0,
    39959630797262630000.0,
    1.7182641242822924e+21,
    47.0,
    2209.0,
    103823.0,
    4879681.0,
    229345007.0,
    10779215329.0,
    506623120463.0,
    23811286661761.0,
    1119130473102763.0,
    52599132235830060.0,
    2472159215084006000.0,
    116191483108947950000.0,
    5.460999706120577e+21,
    53.0,
    2809.0,
    148877.0,
    7890481.0,
    418195493.0,
    22164361129.0,
    1174711139837.0,
    62259690411361.0,
    3299763591802133.0,
    174887470365513440.0,
    9269035929372234000.0,
    491258904256726040000.0,
    2.603672192560654e+22,
    59.0,
    3481.0,
    205379.0,
    12117361.0,
    714924299.0,
    42180533641.0,
    2488651484819.0,
    146830437604321.0,
    8662995818654951.0,
    511116753300641800.0,
    30155888444737847000.0,
    1.7791974182395445e+21,
    1.0497264767613306e+23,
    61.0,
    3721.0,
    226981.0,
    13845841.0,
    844596301.0,
    51520374361.0,
    3142742836021.0,
    191707312997281.0,
    11694146092834184.0,
    713342911662882000.0,
    43513917611435926000.0,
    2.654348974297599e+21,
    1.6191528743215284e+23,
    67.0,
    4489.0,
    300763.0,
    20151121.0,
    1350125107.0,
    90458382169.0,
    6060711605323.0,
    406067677556640.0,
    27206534396294936.0,
    1822837804551752200.0,
    122130132904967670000.0,
    8.182718904632853e+21,
    5.4824216661039854e+23,
    71.0,
    5041.0,
    357911.0,
    25411681.0,
    1804229351.0,
    128100283921.0,
    9095120158391.0,
    645753531245761.0,
    45848500718449010.0,
    3255243551009876500.0,
    231122292121701060000.0,
    1.6409682740640878e+22,
    1.1650874745855012e+24,
    73.0,
    5329.0,
    389017.0,
    28398241.0,
    2073071593.0,
    151334226289.0,
    11047398519097.0,
    806460091894080.0,
    58871586708267920.0,
    4297625829703565300.0,
    313726685568358550000.0,
    2.290204804649021e+22,
    1.671849507393788e+24,
];

static CALC_VARS: [f64; 310] = [
    5.0,
    25.0,
    125.0,
    625.0,
    3125.0,
    15625.0,
    78125.0,
    390625.0,
    1953125.0,
    9765625.0,
    48828125.0,
    244140625.0,
    1220703125.0,
    6103515625.0,
    30517578125.0,
    152587890625.0,
    762939453125.0,
    3814697265625.0,
    19073486328125.0,
    95367431640625.0,
    476837158203123.0,
    2384185791015619.0,
    11920928955078128.0,
    59604644775390380.0,
    298023223876952770.0,
    1490116119384757200.0,
    7450580596923808000.0,
    37252902984619140000.0,
    186264514923094900000.0,
    931322574615477200000.0,
    4.6566128730773657e+21,
    7.0,
    49.0,
    343.0,
    2401.0,
    16807.0,
    117649.0,
    823543.0,
    5764801.0,
    40353607.0,
    282475249.0,
    1977326743.0,
    13841287201.0,
    96889010407.0,
    678223072849.0,
    4747561509943.0,
    33232930569601.0,
    232630513987206.0,
    1628413597910448.0,
    11398895185373156.0,
    79792266297611680.0,
    558545864083282750.0,
    3909821048582987000.0,
    27368747340080964000.0,
    191581231380565720000.0,
    1.3410686196639628e+21,
    9.387480337647757e+21,
    6.571236236353396e+22,
    4.599865365447386e+23,
    3.2199057558131767e+24,
    2.2539340290692278e+25,
    1.5777538203484512e+26,
    11.0,
    121.0,
    1331.0,
    14641.0,
    161051.0,
    1771561.0,
    19487171.0,
    214358881.0,
    2357947691.0,
    25937424601.0,
    285311670611.0,
    3138428376721.0,
    34522712143931.0,
    379749833583240.0,
    4177248169415652.0,
    45949729863572260.0,
    505447028499295740.0,
    5559917313492264000.0,
    61159090448414580000.0,
    672749994932561600000.0,
    7.400249944258193e+21,
    8.14027493868397e+22,
    8.954302432552383e+23,
    9.84973267580764e+24,
    1.0834705943388424e+26,
    1.191817653772729e+27,
    1.3109994191499952e+28,
    1.4420993610649872e+29,
    1.5863092971715003e+30,
    1.744940226888641e+31,
    1.9194342495775223e+32,
    13.0,
    169.0,
    2197.0,
    28561.0,
    371293.0,
    4826809.0,
    62748517.0,
    815730721.0,
    10604499373.0,
    137858491849.0,
    1792160394037.0,
    23298085122481.0,
    302875106592253.0,
    3937376385699293.0,
    51185893014090780.0,
    665416609183179900.0,
    8650415919381334000.0,
    112455406951957300000.0,
    1.4619202903754442e+21,
    1.9004963774880767e+22,
    2.4706452907344985e+23,
    3.2118388779548467e+24,
    4.175390541341299e+25,
    5.428007703743725e+26,
    7.056410014866789e+27,
    9.173333019326887e+28,
    1.1925332925124863e+30,
    1.5502932802662425e+31,
    2.0153812643461e+32,
    2.6199956436499475e+33,
    3.405994336744906e+34,
    17.0,
    289.0,
    4913.0,
    83521.0,
    1419857.0,
    24137569.0,
    410338673.0,
    6975757441.0,
    118587876497.0,
    2015993900449.0,
    34271896307633.0,
    582622237229764.0,
    9904578032905940.0,
    168377826559401440.0,
    2862423051509811700.0,
    48661191875666936000.0,
    827240261886340200000.0,
    1.4063084452067722e+22,
    2.3907243568515193e+23,
    4.064231406647565e+24,
    6.909193391300879e+25,
    1.1745628765211527e+27,
    1.996756890085965e+28,
    3.39448671314615e+29,
    5.770627412348389e+30,
    9.81006660099229e+31,
    1.6677113221686936e+33,
    2.835109247686787e+34,
    4.8196857210675505e+35,
    8.193465725814742e+36,
    1.39288917338851e+38,
    19.0,
    361.0,
    6859.0,
    130321.0,
    2476099.0,
    47045881.0,
    893871739.0,
    16983563041.0,
    322687697779.0,
    6131066257801.0,
    116490258898219.0,
    2213314919066156.0,
    42052983462257020.0,
    799006685782879100.0,
    15181127029874727000.0,
    288441413567620250000.0,
    5.480386857784793e+21,
    1.0412735029791123e+23,
    1.9784196556603026e+24,
    3.758997345754581e+25,
    7.142094956933715e+26,
    1.3569980418173984e+28,
    2.5782962794530793e+29,
    4.8987629309608236e+30,
    9.307649568825514e+31,
    1.7684534180768627e+33,
    3.360061494346021e+34,
    6.384116839257404e+35,
    1.2129821994589174e+37,
    2.30466617897193e+38,
    4.378865740046706e+39,
    23.0,
    529.0,
    12167.0,
    279841.0,
    6436343.0,
    148035889.0,
    3404825447.0,
    78310985281.0,
    1801152661463.0,
    41426511213649.0,
    952809757913927.0,
    21914624432020316.0,
    504036361936467260.0,
    11592836324538747000.0,
    266635235464391200000.0,
    6.132610415680998e+21,
    1.4105003956066294e+23,
    3.2441509098952473e+24,
    7.4615470927590685e+25,
    1.7161558313345857e+27,
    3.9471584120695755e+28,
    9.078464347759958e+29,
    2.0880467999847757e+31,
    4.802507639965018e+32,
    1.104576757191962e+34,
    2.5405265415414946e+35,
    5.843211045545395e+36,
    1.3439385404754505e+38,
    3.091058643093558e+39,
    7.109434879115133e+40,
    1.635170022196469e+42,
    29.0,
    841.0,
    24389.0,
    707281.0,
    20511149.0,
    594823321.0,
    17249876309.0,
    500246412961.0,
    14507145975869.0,
    420707233300200.0,
    12200509765705818.0,
    353814783205468900.0,
    10260628712958603000.0,
    297558232675799660000.0,
    8.629188747598196e+21,
    2.5024647368034783e+23,
    7.257147736730091e+24,
    2.1045728436517273e+26,
    6.103261246590013e+27,
    1.769945761511092e+29,
    5.132842708382171e+30,
    1.4885243854308302e+32,
    4.31672071774941e+33,
    1.2518490081473297e+35,
    3.630362123627258e+36,
    1.0528050158519053e+38,
    3.0531345459705275e+39,
    8.854090183314534e+40,
    2.5676861531612162e+42,
    7.446289844167531e+43,
    2.1594240548085854e+45,
    31.0,
    961.0,
    29791.0,
    923521.0,
    28629151.0,
    887503681.0,
    27512614111.0,
    852891037441.0,
    26439622160671.0,
    819628286980800.0,
    25408476896404860.0,
    787662783788552800.0,
    24417546297445028000.0,
    756943935220797900000.0,
    2.3465261991844634e+22,
    7.274231217471855e+23,
    2.2550116774162813e+25,
    6.990536199990441e+26,
    2.167066221997027e+28,
    6.717905288190802e+29,
    2.0825506393391544e+31,
    6.455906981951396e+32,
    2.0013311644049382e+34,
    6.204126609655325e+35,
    1.9232792489931285e+37,
    5.962165671878714e+38,
    1.8482713582824064e+40,
    5.7296412106754755e+41,
    1.7761887753094022e+43,
    5.5061852034590836e+44,
    1.7069174130723204e+46,
    37.0,
    1369.0,
    50653.0,
    1874161.0,
    69343957.0,
    2565726409.0,
    94931877133.0,
    3512479453921.0,
    129961739795077.0,
    4808584372417840.0,
    177917621779460300.0,
    6582952005840040000.0,
    243569224216081760000.0,
    9.012061295994972e+21,
    3.334462679518144e+23,
    1.2337511914217147e+25,
    4.564879408260351e+26,
    1.6890053810563196e+28,
    6.24931990990839e+29,
    2.312248366666107e+31,
    8.555318956664608e+32,
    3.165468013965909e+34,
    1.1712231651673877e+36,
    4.33352571111934e+37,
    1.6034045131141576e+39,
    5.932596698522391e+40,
    2.195060778453256e+42,
    8.121724880277058e+43,
    3.005038205702515e+45,
    1.111864136109932e+47,
    4.113897303606753e+48,
];

type EncodedHash = String;

pub struct Hashell {
    out_len: u32,
}

impl Hashell {
    pub fn new(hash_length: u32) -> Self {
        Hashell {
            out_len: hash_length,
        }
    }

    pub fn digest(&self, input: &str) -> String {
        if input.len() == 0 {
            panic!("Function cannot be computed for empty strings!");
        }

        self.hash_number(self.hash_encode(input))
    }

    fn hash_encode(&self, inp: &str) -> EncodedHash {
        let mut next_iter = inp.chars().cycle().skip(2);

        inp.chars()
            .enumerate()
            .fold(String::new(), |acc, (i, letter)| {
                let letter_number = find_in_alphabet(letter).expect("Unknown symbols in input!");
                let letter_next =
                    find_in_alphabet(next_iter.next().unwrap()).expect("Unknown symbols in input!");

                acc + ((letter_number
                    + (BIG_PRIME
                        * ((ALF_PRIME + 17 * (i as u32 + 1)) % (i as u32 + 1 + letter_next))))
                    % (MAX_CODE - 1))
                    .to_string()
                    .as_str()
            })
    }

    fn hash_number(&self, inp: EncodedHash) -> String {
        let mut hash_history = VecDeque::new();
        //let mut test = vec![];
        let mut hash = String::with_capacity(self.out_len as usize);
        let parsed_inp = inp.parse::<f64>().unwrap();

        let mut pair_left = inp.chars().cycle().skip(2).step_by(6);
        let mut pair_right = inp.chars().cycle().skip(1).step_by(6);

        for i in 0..(inp.len() as u32 + 1) / 2 {
            let val_left = pair_left.next().unwrap().to_digit(10).unwrap();
            let val_right = pair_right.next().unwrap().to_digit(10).unwrap();

            let pair_val = val_left * 10 + val_right;

            hash_history.push_back(
                ((pair_val
                    + (PRIMELIST
                        .get((val_left as usize).wrapping_sub(1))
                        .unwrap_or(&0)
                        * i
                        * 3))
                    % ALF_PRIME)
                    + 1,
            );
        }

        for _ in 0..((self.out_len + 2000) as f64 / hash_history.len() as f64)
            .log2()
            .ceil() as u32
        //for _ in 0..(((self.out_len + 2000) as f64 / hash_history.len() as f64).log10() / 0.3010299956639812).ceil() as u32
        {
            let mut h = vec_get(&hash_history, (hash_history.len() + 1) / 2 - 1);

            for _ in 0..hash_history.len() {
                h = 1 + ((h + BIG_PRIME) % hash_history.len() as u32);

                let hash_val = vec_get(&hash_history, h as usize - 1);

                let v = (primelist_get(((h % (10 + self.out_len)) + 19) as usize) * hash_val)
                    % inp.len() as u32;

                let inp_val = inp
                    .chars()
                    .skip(v as usize)
                    .next()
                    .unwrap_or('0')
                    .to_digit(10)
                    .unwrap() as f64;

                let prime_val = primelist_get(h as usize % PRIMELIST.len());

                let calc_val = CALC_VARS
                    .get(((hash_val % 31) + (h % 10) * 31) as usize)
                    .unwrap_or(&0.0);

                let final_val = 1
                    + ((inp_val
                        + (hash_val as f64
                            + (vec_get(
                                &hash_history,
                                (prime_val + hash_val) as usize % hash_history.len(),
                            ) as f64
                                + calc_val)))
                        % 241.0) as u32;

                hash_history.push_back(final_val);
            }
        }

        let mut summ = self.out_len;
        for _ in 0..hash_history.len() - (self.out_len as usize + 1000) {
            summ = (summ + hash_history.pop_front().unwrap_or(0)) % 3011;
        }

        for _ in 0..hash_history.len() - (self.out_len as usize + 500) {
            let counter = ((PRIMELIST.last().unwrap() % 11) + summ) as usize % hash_history.len();
            summ = (summ + hash_history.remove(counter).unwrap_or(0)) % 3011;
        }

        let mut h = vec_get(&hash_history, (hash_history.len() + 1) / 2 - 1);
        for _ in 0..25 + vec_get(&hash_history, 0) % 23 {
            for _ in 0..hash_history.len() {
                h = 1 + ((h + 1) % hash_history.len() as u32);

                let hash_val = vec_get(&hash_history, h as usize - 1);

                let inp_val = inp
                    .chars()
                    .skip((h as f64 % parsed_inp) as usize)
                    .next()
                    .unwrap_or('0')
                    .to_digit(10)
                    .unwrap();

                let comb_val =
                    (inp_val + hash_val + ((h - 1) % hash_history.len() as u32) * 17) as f64;

                let vec_val = vec_get(
                    &hash_history,
                    (primelist_get(h as usize % PRIMELIST.len()) * hash_val) as usize
                        % hash_history.len(),
                ) as f64;

                let exp_val = EXP_VARS
                    .get((((h + summ) % 13) + (hash_val % 10) * 13) as usize)
                    .unwrap();

                let final_val = 1 + ((comb_val + (vec_val + exp_val)) % 1013.0) as u32;

                *hash_history.get_mut(h as usize - 1).unwrap() = final_val;
            }
            hash_history.pop_front();
            if vec_get(&hash_history, 0) % 2 == 1 {
                hash_history.remove(12);
            }
        }

        for _ in 0..10 {
            hash_history.insert(
                hash_history.len() - (5 + self.out_len as usize % 11) - 1,
                *hash_history.front().unwrap(),
            );
            hash_history.pop_front();
            hash_history.push_back(vec_get(&hash_history, self.out_len as usize - 1));
            hash_history.remove(self.out_len as usize - 1);
        }

        for _ in 0..self.out_len {
            let inp_val = inp
                .chars()
                .skip(
                    (vec_get(
                        &hash_history,
                        (hash_history.len() as f64 / 50.0).round() as usize,
                    ) as f64
                        % parsed_inp) as usize,
                )
                .next()
                .unwrap_or('0')
                .to_digit(10)
                .unwrap();

            let hash_range = hash.len()..=hash.len();
            if vec_get(&hash_history, 0) % 2 == inp_val % 2 {
                hash.push_str(((vec_get(&hash_history, 0) as f64 / 10.0).round() as u32 % 10).to_string().as_str());
                let hash_letter = hash[hash_range].parse().expect("parsed slice");
                for _ in 0..hash_letter {
                    hash_history.insert(hash_history.len() - 4, vec_get(&hash_history, 3));
                    hash_history.remove(3);
                }
            } else {
                hash.push_str((vec_get(&hash_history, 0) % 10).to_string().as_str());
                let hash_letter = hash[hash_range].parse().expect("parsed slice");
                for _ in 0..4 {
                    hash_history.push_back(vec_get(&hash_history, hash_letter));
                    hash_history.remove(hash_letter);
                }
            }

            hash_history.insert(hash_history.len() - 11, vec_get(&hash_history, 0));
            hash_history.remove(0);
        }

        hash
    }
}

#[inline]
fn vec_get(vec: &VecDeque<u32>, idx: usize) -> u32 {
    *vec.get(idx).unwrap_or(&0)
}

#[inline]
fn primelist_get(idx: usize) -> u32 {
    *PRIMELIST.get(idx).unwrap_or(&0)
}

fn find_in_alphabet(char: char) -> Option<u32> {
    let mut accum = 0;
    ALPHABET.chars().find(|&v| {
        accum += 1;
        v == char
    })?;

    Some(accum)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_alphabet() {
        assert_eq!(find_in_alphabet('д'), Some(73));
        assert_eq!(find_in_alphabet('4'), Some(6));
        assert_eq!(find_in_alphabet('e'), Some(47));
        assert_eq!(find_in_alphabet('\\'), Some(19));
        assert_eq!(find_in_alphabet('"'), Some(40));
        assert_eq!(find_in_alphabet(' '), Some(1));
        assert_eq!(find_in_alphabet('Ы'), None);
    }

    #[test]
    fn hash_encode_test() {
        let hashell = Hashell::new(0);

        assert_eq!(
            hashell.hash_encode("486486313653298"),
            "18369657183482421359888518530247712270482".to_owned()
        );
        assert_eq!(
            hashell.hash_encode("fie30a9fhafh9wjnsp0"),
            "46528728377671058223115703991284538790667241351769825356".to_owned()
        );
        assert_eq!(
            hashell.hash_encode("-020-4i032230fo"),
            "13615946119430140565153618124041860052116".to_owned()
        );
        assert_eq!(
            hashell.hash_encode("  wwpoj3ropawjo"),
            "1901789549586247029260330852971955663701411".to_owned()
        );
        assert_eq!(hashell.hash_encode("]]30r30]iir3]0]r30]-r0i30wqqrw30-j"), "319065824141868362089442283047729756599494547735686119071365173902419132421299123360831486430882".to_owned());
        assert_eq!(
            hashell.hash_encode("394334512383894"),
            "6424712464477419125298535182144776974187".to_owned()
        );
        assert_eq!(
            hashell.hash_encode("8778484646941145632546"),
            "1030468187655416589395067601419622987737083453663365541716".to_owned()
        );

        assert_eq!(hashell.hash_encode("0"), "2".to_owned());
    }

    #[test]
    fn hash_number_test() {
        let hashell = Hashell::new(16);

        assert_eq!(
            "0555279339417795".to_owned(),
            hashell.digest("3483488345939349")
        );

        assert_eq!(
            "3973351530153453".to_owned(),
            hashell.digest("0")
        );

        assert_eq!(
            "1095160231297737".to_owned(),
            hashell.digest("1")
        );

        let hashell = Hashell::new(15);

        assert_eq!(
            "755539785697931".to_owned(),
            hashell.digest("394334512383894")
        );

        assert_eq!(
            "933097009979939".to_owned(),
            hashell.digest("8778484646941145632546")
        );

        assert_eq!(
            "736348119714255".to_owned(),
            hashell.digest("asrgaeфыкрфкр4984612")
        );

        let hashell = Hashell::new(120);

        assert_eq!(
            "678779357945397196395199965043199010191399199043079718719201731813323999879713959292058944979749150493093286654673351543".to_owned(),
            hashell.digest("394334512383894")
        );

        assert_eq!(
            "914937769319477494315979533594219379210994159831194102531133189333595613942051627930572350359741979903311599949173916579".to_owned(),
            hashell.digest("8778484646941145632546")
        );

        assert_eq!(
            "943891315585135305317517730943583572837303418114493569641982101018331964979535915753136415018093539879929973199912995333".to_owned(),
            hashell.digest("asrgaeфыкрфкр4984612")
        );
    }

    #[test]
    #[should_panic]
    fn hash_empty_string() {
        let hasher = Hashell::new(10);
        hasher.digest("");
    }
}
